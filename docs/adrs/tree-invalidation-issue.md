# ADR-004: Принудительное пересоздание компонента Tree для решения проблемы с обновлением

* **Статус:** Принято
* **Дата:** 2025-10-26

## Контекст

Компонент дерева `WorldObjectTree.tsx`, который использует `Tree` из библиотеки Ant Design с ленивой загрузкой данных (`loadData`), столкнулся с проблемой. После изменения данных в категории (например, создание нового объекта), дочерние узлы этой категории не обновлялись при ее повторном раскрытии. Функция `onLoadData` не вызывалась.

Проблема сохранялась даже после рефакторинга с целью обеспечить полную иммутабельность обновлений состояния (создание новых массивов и объектов вместо мутации). Попытки вручную удалить свойство `children` у соответствующего узла в состоянии не приводили к желаемому результату, что указывает на то, что компонент `Tree` сохранял где-то внутри себя устаревшее состояние.

## Решение

Применить стратегию принудительного пересоздания ("re-mounting") компонента `Tree` в `WorldObjectTree.tsx`.

Это достигается следующим образом:

1. В состояние компонента добавляется переменная `treeKey`.
2. К компоненту `<Tree>` добавляется проп `key={treeKey}`.
3. Каждый раз, когда происходит событие `world-objects-changed`, которое требует обновления дерева, мы не только обновляем данные (`treeData`), но и изменяем значение `treeKey` (например, инкрементируем счетчик).

Когда React видит, что `key` компонента изменился, он гарантированно уничтожает старый экземпляр компонента и создает совершенно новый с последними пропами.

## Последствия

### Положительные

* **Надежность:** Это решение гарантированно устраняет проблему, так как внутреннее состояние компонента `Tree` полностью уничтожается, предотвращая любые конфликты с устаревшим состоянием.
* **Простота:** Логика проста для понимания и реализации, в отличие от более сложных попыток отладки внутреннего поведения сторонней библиотеки.

### Отрицательные

* **Производительность:** Полное пересоздание компонента менее производительно, чем его точечное обновление. Однако для дерева навигации, которое не содержит тысяч одновременно видимых узлов, это влияние пренебрежимо мало.
* **Потеря состояния UI:** Если бы у дерева было внутреннее состояние, не контролируемое React (например, позиция скролла), оно бы сбрасывалось. В данном конкретном случае это не является проблемой.
